%{
#include "hw3_output.hpp"
#include <iostream>
#include <stdlib.h>
#include "Types.hpp"
#include "SymbolTable.hpp"
extern int yylex();
extern int yylineno;
using namespace output;
int yyerror(const char * message);
SymbolTable* symbol_table = &(SymbolTable::getSymbolTable());
%}

%nonassoc ID
%nonassoc VOID
%nonassoc OVERRIDE
%nonassoc STRING
%nonassoc NUM
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL

%right ASSIGN
%left OR
%left AND

%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%nonassoc IF
%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE

%nonassoc COMMA

%left EQUALOP
%left RELOP
%left SUMOP
%left MULTIPLEOP
%right NOT
%left LPAREN
%left RPAREN
%left SC
%left LBRACE
%left RBRACE

%nonassoc ELSE

%nonassoc END

%%
/*declarations*/

Program    : Funcs END {
    if (!symbol_table->mainExists()) {
        errorMainMissing();
        exit(1);
    }
    symbol_table->closeScope();
    exit(0);
}

Funcs      : /*epsilon*/ {}
| FuncDecl Funcs {}

FuncDecl   : OverRide RetType ID LPAREN Formals {

    override_t* override = (override_t*)$1;
    retType_t* returnType = (retType_t*)$2;
    ID_t* id = (ID_t*)$3;
    formals_t* formals = (formals_t*)$5;

    symbol_table->declFunc(id->ID_name, returnType->type, formals, override->isOverRide, yylineno);

    $$ = new funcDeclarations_t(returnType->type, formals->declarations, id->ID_name);

 }
 RPAREN LBRACE Statements RBRACE {
    symbol_table->curr_func_type = NULL_TYPE;
    symbol_table->closeScope();
 }

override   : /*epsilon*/ { $$ = new override_t(false); }
| OVERRIDE { $$ = new override_t(true); }

RetType    : Type {
    type_t* type = (type_t*)$1;
    $$ = new retType_t(type->type);
}
| VOID { $$ = new retType_t(VOID); }

Formals    : /*epsilon*/ { $$ = new formals_t(); }
| FormalsList { $$ = new formals_t(((formalsList_t*)$1)->declarations); }

FormalsList :  formalDeclarations_t  {
    std::vector<formalDeclarations_t*> vec;
    vec.insert(vec.begin(), (formalDeclarations_t*)$1);
    formalsList_t* formals_list = new formalsList_t(vec);
    $$ = formals_list;
}

| FormalDecl COMMA FormalsList {
    formalDeclarations_t* formal_dec = (formalDeclarations_t*)$1;
    formalsList_t* formal_list = (formalsList_t*)$3;
    ///formal_list->declarations.push_back(formal_dec);
    formal_list->declarations.insert(formal_list->declarations.begin(), formal_dec);

    $$ = new formalsList_t(formal_list->declarations);
}

FormalDecl : Type ID {
    ID_t* id = (ID_t*)$2;
    type_t* type = (type_t*)$1;
    /// #TODO check piazza for currentscope / all scopes becase I think we cant do shadowing
    if (symbol_table->isInCurrScope(id->ID_name)) {
        errorDef(yylineno, id->ID_name);
        exit(1);
    }
    formalDeclarations_t* formal = new formalDeclarations_t(type->type, id->ID_name);
    $$ = formal;
}

Statements : Statement
| Statements Statement {}

Statement  : LBRACE OpenScope Statements RBRACE CloseScope { }
| Type ID SC {
    type_t* type = (type_t*)$1;
    ID_t* id = (ID_t*)$2;
    if (symbol_table->symbDeclared(id->ID_name)) {
      errorDef(yylineno, id->ID_name);
      exit(1);
    }
    symbol_table->declareVar(id->ID_name, type->type);
}

| Type ID ASSIGN Expr SC {
    type_t* type = (type_t*)$1;
    ID_t* id = (ID_t*)$2;
    expr_t* exp = (expr_t*)$4;
    if (symbol_table->symbDeclared(id->ID_name)) {
        errorDef(yylineno, id->ID_name);
        exit(1);
    }
    else {
        if (AssignLegality(type->type, exp->type)) {
            symbol_table->declareVar(id->ID_name, type->type);
        }
        else {
            errorMismatch(yylineno);
            exit(1);
        }
    }
}
| ID ASSIGN Expr SC {
    ID_t* id = (ID_t*)$1;
    expr_t* exp = (expr_t*)$3;
    if (!symbol_table->symbDeclared(id->ID_name)) {
        errorUndef(yylineno, id->ID_name);
        exit(1);
    }
    else {
        TypesEnum type = symbol_table->getIDType(id->ID_name);
        if (!AssignLegality(type, exp->type)) {
            errorMismatch(yylineno);
            exit(1);
        }
    }
}
| Call SC {}
| RETURN SC {
    if(symbol_table->curr_func_type != VOID)
    {
        errorMismatch(yylineno);
        exit(1);
    }
}
| RETURN Expr SC {
    expr_t* exp = (expr_t*)$2;
    if(!AssignLegality(symbol_table->curr_func_type, exp->type)) {
        errorMismatch(yylineno);
        exit(1);
    }
}
| IF LPAREN IsExpBool RPAREN OpenScope Statement CloseScope
| IF LPAREN IsExpBool RPAREN OpenScope Statement CloseScope ELSE OpenScope Statement CloseScope
| WHILE LPAREN IsExpBool RPAREN WhileScope Statement CloseScope
| BREAK SC  {
    bool inWhile = symbol_table->isGlobalScopeInWhile();
    if(!inWhile)
    {
        errorUnexpectedBreak(yylineno);
        exit(1);
    }
}
| CONTINUE SC {
    bool inWhile = symbol_table->isGlobalScopeInWhile();
    if(!inWhile)
    {
        errorUnexpectedContinue(yylineno);
        exit(1);
    }
}

Call      :  ID LPAREN ExpList RPAREN {
    ID_t* id = (ID_t*)$1;
    exprList_t* expr_list = (exprList_t*)$3;
    bool isDec = symbol_table->isDeclared(id->ID_name, true);
    if(!isDec)
    {
         errorUndefFunc(yylineno, id->ID_name);
         exit(1);
    }
    symbol_table->checkFuncParams(id->ID_name, expr_list->exprs, yylineno);
    $$ = new call_t(symbol_table->getFuncType(id->ID_name, expr_list->exprs), id->ID_name);
}
| ID LPAREN RPAREN {
    ID_t* id = (ID_t*)$1;
    if(!symbol_table->isDeclared(id->ID_name, true))
    {
         errorUndefFunc(yylineno, id->ID_name);
         exit(1);
    }
    symbol_table->checkFuncParams(id->ID_name, yylineno);
    std::vector<expr_t*> exprs;
    $$ = new call_t(symbol_table->getFuncType(id->ID_name,exprs), id->ID_name);
}

ExpList   :  Expr {
    std::vector<expr_t*> exprs;
    exprs.push_back((expr_t*)$1);
    $$ = new exprList_t(exprs);
}
| Expr COMMA ExpList {
    exprList_t* expr_list = (exprList_t*)$3;
    expr_list->exprs.push_back((expr_t*)$1);
    $$ = new exprList_t(expr_list->exprs);
}

Type      : INT  {$$ = new type_t(INT);}
|  BYTE {$$ = new type_t(BYTE);}
|  BOOL {$$ = new type_t(BOOL);}

Expr      : LPAREN  Expr RPAREN  { $$ = new expr_t(((expr_t*)$2)->type); }
| Expr SUMOP Expr {
    expr_t* first = (expr_t*)$1;
    expr_t* second = (expr_t*)$3;
    TypesEnum type = SumType(first->type, second->type);
    if (type == NULL_TYPE) {
        errorMismatch(yylineno);
        exit(1);
    }
    $$ = new expr_t(type);
}
| Expr MULTIPLEOP Expr {
    expr_t* first = (expr_t*)$1;
    expr_t* second = (expr_t*)$3;
    TypesEnum type = SumType(first->type, second->type);
    if (type == NULL_TYPE) {
        errorMismatch(yylineno);
        exit(1);
    }
    $$ = new expr_t(type);
}
| ID   { ID_t* id = (ID_t*)$1;

          if (!symbol_table->isDeclared(id->ID_name)) {
                 errorUndef(yylineno, id->ID_name);
                 exit(1);
             }
          $$ = new expr_t(symbol_table->getIDType(id->ID_name));
          }
| Call { $$ = new expr_t(((call_t*)$1)->type); }
| NUM {$$ = new expr_t(INT);}
| NUM B {
    num_t* num = (num_t*)$1;
    if (stoi(num->num_val) > 255)
    {
        errorByteTooLarge(yylineno, num->num_val);
        exit(1);
    }
    $$ = new expr_t(BYTE);
}
| STRING {$$ = new expr_t(STRING);}
| TRUE {$$ = new expr_t(BOOL);}
| FALSE {$$ = new expr_t(BOOL);}
| NOT Expr {
    expr_t* exp = (expr_t*)$2;
    if (exp->type != BOOL) {
        errorMismatch(yylineno);
        exit(1);
    }
    $$ = new expr_t(BOOL);
}
| Expr AND Expr {
    expr_t* first = (expr_t*)$1;
    expr_t* second = (expr_t*)$3;
    if (first->type != BOOL  || second->type != BOOL ) {
        errorMismatch(yylineno);
        exit(1);
    }
    $$ = new expr_t(BOOL);
}
| Expr OR Expr {
    expr_t* first = (expr_t*)$1;
    expr_t* second = (expr_t*)$3;
    if (first->type != BOOL  || second->type != BOOL ) {
        errorMismatch(yylineno);
        exit(1);
    }
    $$ = new expr_t(BOOL);
}
| Expr RELOP Expr {
    expr_t* first = (expr_t*)$1;
    expr_t* second = (expr_t*)$3;
    TypesEnum type = SumType(first->type, second->type);
    if (type == NULL_TYPE) {
        errorMismatch(yylineno);
        exit(1);
    }
    $$ = new expr_t(BOOL);
}
| Expr EQUALOP Expr {
    expr_t* first = (expr_t*)$1;
    expr_t* second = (expr_t*)$3;
    TypesEnum type = SumType(first->type, second->type);
    if (type == NULL_TYPE) {
        errorMismatch(yylineno);
        exit(1);
    }
    $$ = new expr_t(BOOL);
}
| LPAREN Type RPAREN Expr {
    type_t* type = (type_t*)$2;
    expr_t* exp = (expr_t*)$4;
    if(ConversionLegality(exp->type , type->type)) {
        $$ = new expr_t(type->type);
    }
    else
    {
        errorMismatch(yylineno);
        exit(1);
    }
 }

 IsExpBool : Expr { if ((*(expr_t*)$1).type != BOOL)
                {
                    errorMismatch(yylineno);
                    exit(1);
                }}
 OpenScope : /*epsilon*/ { symbol_table->openScope(); }
 WhileScope: /*epsilon*/ { symbol_table->openScope(true); }
 CloseScope: /*epsilon*/  { symbol_table->closeScope(); }
%%

int main()
{
    symbol_table->init();
	yyparse();
}

int yyerror(const char * message)
{
	errorSyn(yylineno);
	exit(1);
}